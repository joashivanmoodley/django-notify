=============
django.contrib.messages
=============

A Django application which provides temporary messages.

Messages persist until a request retrieves them.


Installation
============

Add the middleware to your ``MIDDLEWARE_CLASSES`` setting (the default
temporary storage relies on Django's ``contrib.sessions`` application, so place
this after ``SessionMiddleware``)::

    'django.contrib.messages.middleware.MessagesMiddleware',

To make it easy to access messages in templates, add the context processor
into your ``TEMPLATE_CONTEXT_PROCESSORS`` setting::

    'django.contrib.messages.context_processors.messages',


Usage
=====

Adding a message
-----------------------------

The middleware attaches an instance of a temporary storage class called
``messages`` to your ``request``. To add a message, call::

    request.messages.add('Hello world.')

Some other methods provide a standard way to add messages with commonly
used tags (which are usually represented as HTML classes for the message)::

    request.messages.debug('%s SQL statements were executed.' % count)
    request.messages.success('Profile details updated.')
    request.messages.warning('Your account expires in three days.')
    request.messages.error('Document deleted.')


Displaying messages
--------------------------------

In your template, use something like::

	{% if messages %}
	<ul class="messages">
		{% for message in messages %}
		<li{% if message.tags %} class="{{ message.tags }}"{% endif %}>{{ message }}</li>
		{% endfor %}
	</ul>
	{% endif %}

If you're using the context processor, your template should be rendered with a
``RequestContext``. Otherwise, ensure ``request.messages`` is available to
the template context.


Expiration of messages
-----------------------------------

The messages are marked to be cleared when the storage instance is
iterated (and cleared when the response is processed).

To avoid the messages being cleared, you can set
``request.messages.used = False`` after iterating.


Message Levels
-------------------

The ``MESSAGES_LEVEL`` setting can be used to change the minimum recorded
level. Attempts to add messages of a level less than this will be ignored.

The built-in levels (which can be imported from ``django.contrib.messages`` 
directly) are:

===========  =====  ===========
Constant     Level  Default Tag
===========  =====  ===========
``DEBUG``    10     ``debug``
``INFO``     20     
``SUCCESS``  25     ``success``
``WARNING``  30     ``warning``
``ERROR``    40     ``error``
===========  =====  ===========

``INFO`` is the default minimum recorded level. It is also the
default level of the ``add`` method.

The minimum recorded level can also be set per request by changing the
``level`` attribute of the messages storage instance::

    from django.contrib import messages
    
    # Change the messages level to ensure the debug message is added.
    request.messages.level = messages.DEBUG
    request.messages.debug('Test message...')
    
    # Set the messages level back to default.
    request.messages.level = None


Custom Tags
-----------

To provide custom tags for message levels (either built in levels or
custom ones), set the ``MESSAGES_TAGS`` setting to a dictionary
containing the levels you wish to change. As this extends the default tags,
you only need to provide tags for the levels you wish to override::

    from django.contrib import messages
    MESSAGES_TAGS = {
        messages.INFO: 'info',
        50: 'critical',
    }

For more direct control over message tags, you can optionally provide a string
containing extra tags to any of the add methods::

    request.messages.add('Over 9000!', extra_tags='dragonball')
    request.messages.error('Email box full', extra_tags='email')

Extra tags are added before any default tag for that level (space separated).


Temporary Storage Backends
==========================

``djanog.contrib.messages`` can use different backends to store temporary 
messages. To change which backend is being used, add a ``MESSAGES_STORAGE`` to 
your settings, referencing to the module and class of the storage class. For 
example::

    MESSAGES_STORAGE = 'cookie.CookieStorage'

``djanog.contrib.messages`` first looks for the module inside of 
``django.contrib.messages.storage``, and if not found, tries to import the full 
given module directly.

Three temporary storage classes are included:

``'session.SessionStorage'``
    This class stores all messages inside of the request's session. It
    requires Django's ``contrib.session`` application.

``'cookie.CookieStorage'``
    This class stores the message data in a cookie (signed with a secret
    hash to prevent manipulation) to persist messages across requests.
    Old messages are dropped if the cookie data size would exceed 4096 bytes.

``'fallback.FallbackStorage'``
    This is the default temporary storage class.

    This class uses CookieStorage for all messages, falling back to using 
    SessionStorage for the messages which could not fit in a single cookie.

    Since it is uses SessionStorage, it also requires Django's
    ``contrib.session`` application. 

To write your own, subclass the ``BaseStorage`` class in
``django.contrib.messages.storage.base`` and write ``_get`` and ``_store`` methods.
